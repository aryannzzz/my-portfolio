<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Building Financial Agents That Handle Fraud in Milliseconds | Aryan's Portfolio</title>
  <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64," />
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin />
  <link rel="stylesheet" href="../css/blogs/gradCAM(summary).css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans:wght@400;500;700&display=swap" />
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
</head>
<body>
  <div class="layout-container flex flex-col min-h-screen bg-white">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <a href="../index.html" class="logo-link" aria-label="Home">
          <svg class="logo-icon" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g clip-path="url(#clip0_6_319)">
              <path
                d="M8.57829 8.57829C5.52816 11.6284 3.451 15.5145 2.60947 19.7452C1.76794 23.9758 2.19984 28.361 3.85056 32.3462C5.50128 36.3314 8.29667 39.7376 11.8832 42.134C15.4698 44.5305 19.6865 45.8096 24 45.8096C28.3135 45.8096 32.5302 44.5305 36.1168 42.134C39.7033 39.7375 42.4987 36.3314 44.1494 32.3462C45.8002 28.361 46.2321 23.9758 45.3905 19.7452C44.549 15.5145 42.4718 11.6284 39.4217 8.57829L24 24L8.57829 8.57829Z"
                fill="currentColor"
              ></path>
            </g>
            <defs>
              <clipPath id="clip0_6_319"><rect width="48" height="48" fill="white"></rect></clipPath>
            </defs>
          </svg>
          <span class="site-title">Portfolio</span>
        </a>
      </div>
      <nav class="header-nav" aria-label="Main navigation">
        <a href="../projects.html">Projects</a>
        <a href="../resume.html">Resume/About Me</a>
        <a href="../roadmap.html">Roadmap</a>
        <a href="../blogs.html" class="active">Blogs/Insights</a>
        <a href="../contact.html">Contact</a>
      </nav>
      <div class="header-actions">
        <button class="mode-toggle" aria-label="Toggle light/dark mode">
          <svg width="20" height="20" fill="currentColor" viewBox="0 0 256 256">
            <path d="M120,40V16a8,8,0,0,1,16,0V40a8,8,0,0,1-16,0Zm72,88a64,64,0,1,1-64-64A64.07,64.07,0,0,1,192,128Zm-16,0a48,48,0,1,0-48,48A48.05,48.05,0,0,0,176,128ZM58.34,69.66A8,8,0,0,0,69.66,58.34l-16-16A8,8,0,0,0,42.34,53.66Zm0,116.68-16,16a8,8,0,0,0,11.32,11.32l16-16a8,8,0,0,0-11.32-11.32ZM192,72a8,8,0,0,0,5.66-2.34l16-16a8,8,0,0,0-11.32-11.32l-16,16A8,8,0,0,0,192,72Zm5.66,114.34a8,8,0,0,0-11.32,11.32l16,16a8,8,0,0,0,11.32-11.32ZM48,128a8,8,0,0,0-8-8H16a8,8,0,0,0,0,16H40A8,8,0,0,0,48,128Zm80,80a8,8,0,0,0-8,8v24a8,8,0,0,0,16,0V216A8,8,0,0,0,128,208Zm112-88H216a8,8,0,0,0,0,16h24a8,8,0,0,0,0-16Z"></path>
          </svg>
        </button>
        <div class="profile-pic" style='background-image: url("../assets/profile.jpg");' aria-label="Profile picture"></div>
      </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
      <nav class="breadcrumb">
        <a href="../blogs.html">Insights</a>
        <span>/</span>
        <span class="current">Priority-Based Agent Control</span>
      </nav>
      <article class="blog-article">
        <h1 class="blog-title">Building Financial Agents That Handle Fraud in Milliseconds: Priority-Based Preemption</h1>
        <p class="blog-date">Inter IIT Tech Meet | Pathway Problem Statement</p>

        <section class="blog-section">
          <h2>The Millisecond That Costs Millions</h2>
          <p>
            A credit portfolio management agent is analyzing quarterly reports when a fraud alert triggers. The fraud pattern matches a known scheme that has cost banks $50 million in the past 6 months. Every second of delay increases potential losses.
          </p>
          <p>
            What should the agent do? Continue the report analysis and handle fraud later? Drop everything immediately? What if the report analysis is 90% complete and contains critical risk insights?
          </p>
          <p>
            This isn't a hypothetical edge case. Financial agents face constant interruptions: fraud alerts, margin calls, risk breaches, regulatory deadlines, market anomalies. Each event has different urgency, consequences, and time sensitivity.
          </p>
          <p>
            For our Inter IIT project, I designed a priority-based preemption system that makes these split-second decisions automatically, ensuring critical events get immediate attention while preserving work on interrupted tasks.
          </p>
        </section>

        <section class="blog-section">
          <h2>Why Simple Task Queues Fail in Finance</h2>
          <p>
            Traditional task queues process jobs in order (FIFO), or maybe with basic priority levels. But financial systems need something far more sophisticated:
          </p>
          
          <p><strong>The Challenge: Competing Urgencies</strong></p>
          <ul>
            <li><strong>Fraud Alert:</strong> Immediate action required, every second counts, potential loss in millions</li>
            <li><strong>Margin Call:</strong> Regulatory deadline, 30-minute window to respond, legal consequences</li>
            <li><strong>Risk Breach:</strong> Portfolio exceeds VaR limits, needs rebalancing within hours</li>
            <li><strong>Quarterly Rebalancing:</strong> Important but not urgent, can be interrupted and resumed</li>
            <li><strong>Daily Reporting:</strong> Scheduled task, low priority but must complete eventually</li>
          </ul>
          
          <p>
            A simple queue would handle these in order of arrival. A priority queue might handle the urgent ones first, but what about the half-completed quarterly rebalancing? Do you throw away an hour of computation? What if it was about to identify a critical risk?
          </p>
        </section>

        <section class="blog-section">
          <h2>The Priority-Based Preemption Architecture</h2>
          <p>
            I designed a hierarchical state machine with intelligent preemption, inspired by operating system schedulers but adapted for financial workflows.
          </p>
          
          <p><strong>Core Components</strong></p>
          <ol>
            <li><strong>Priority-Based Event Handler:</strong> Assigns urgency scores to incoming events</li>
            <li><strong>State Machine with Stack:</strong> Tracks current and suspended tasks</li>
            <li><strong>Checkpoint Manager:</strong> Saves progress for later resumption</li>
            <li><strong>Preemption Controller:</strong> Decides when to interrupt and when to queue</li>
          </ol>
        </section>

        <section class="blog-section">
          <h2>Priority Levels: Not All Alerts Are Equal</h2>
          <p>
            The system uses a five-level priority hierarchy based on financial impact and time sensitivity:
          </p>
          
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">PRIORITY_LEVELS = {
    'FRAUD_ALERT': 1,      # Highest - immediate action
    'MARGIN_CALL': 2,      # Regulatory deadline
    'RISK_BREACH': 3,      # Portfolio risk management
    'REBALANCE': 4,        # Important but can wait
    'REPORTING': 5         # Lowest - scheduled maintenance
}

def handle_event(event):
    event_priority = PRIORITY_LEVELS[event.type]
    current_priority = get_current_task_priority()
    
    if event_priority < current_priority:  # Lower number = higher priority
        return preempt_current_task(event)
    else:
        return queue_event(event)</pre>
          
          <p>
            The key insight: priority isn't just about importance, it's about the cost of delay. Fraud detection is priority 1 because the cost increases exponentially with time. Reporting is priority 5 because it can wait hours without significant cost.
          </p>
        </section>

        <section class="blog-section">
          <h2>Checkpoint-Based State Management</h2>
          <p>
            When a high-priority event preempts a running task, we don't throw away progress. The system saves a checkpoint containing all necessary state to resume later.
          </p>
          
          <p><strong>What Gets Saved in a Checkpoint</strong></p>
          <ul>
            <li><strong>Progress Percentage:</strong> How far through the task we are</li>
            <li><strong>Partial Results:</strong> Any intermediate computations or analyses</li>
            <li><strong>Resource State:</strong> Database connections, API tokens, file handles</li>
            <li><strong>Timestamp:</strong> When the checkpoint was created</li>
          </ul>
          
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">class PreemptibleTask:
    def save_checkpoint(self):
        """Save current execution state for later resumption"""
        self.checkpoint = {
            'progress': self.progress,
            'partial_results': self.get_partial_results(),
            'resource_state': self.capture_resource_state(),
            'timestamp': time.time(),
            'intermediate_data': self.serialize_state()
        }
        
        # Persist to disk for recovery
        with open(f'checkpoints/{self.task_id}.pkl', 'wb') as f:
            pickle.dump(self.checkpoint, f)
    
    def restore_from_checkpoint(self):
        """Resume task from saved checkpoint"""
        if self.checkpoint:
            self.progress = self.checkpoint['progress']
            self.restore_partial_results(self.checkpoint['partial_results'])
            self.restore_resource_state(self.checkpoint['resource_state'])
            
            # Log resumption for audit trail
            logger.info(f"Task {self.task_id} resumed from {self.progress}% completion")</pre>
        </section>

        <section class="blog-section">
          <h2>The Fraud Alert Preemption Flow</h2>
          <p>
            Let's walk through what happens when a fraud alert interrupts portfolio rebalancing:
          </p>
          
          <p><strong>Step 1: Fraud Alert Arrives</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">fraud_event = {
    'type': 'FRAUD_ALERT',
    'account_id': 'ACC-12345',
    'pattern': 'synthetic_identity',
    'confidence': 0.97,
    'estimated_exposure': 250000,
    'detected_at': '2024-11-14T10:15:30Z'
}</pre>
          
          <p><strong>Step 2: Priority Comparison</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">current_task = rebalancing_agent  # Priority 4
fraud_priority = 1  # Highest priority

# Fraud priority (1) < Current priority (4)
# Preemption is triggered</pre>
          
          <p><strong>Step 3: Save Checkpoint and Suspend</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">async def handle_fraud_alert_preemption(fraud_event):
    # Pause current task
    current_task = self.current_task
    if current_task:
        await current_task.request_pause()
        checkpoint = await current_task.save_checkpoint()
        
        # Push to state stack for later resumption
        self.state_stack.push({
            'task': current_task,
            'checkpoint': checkpoint,
            'timestamp': time.time(),
            'reason': 'FRAUD_ALERT_PREEMPTION'
        })
        
        logger.warning(f"Task {current_task.id} preempted at {checkpoint['progress']}%")</pre>
          
          <p><strong>Step 4: Execute Fraud Handler</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">    # Execute fraud alert handler with full priority
    fraud_handler = FraudAlertHandler(fraud_event)
    try:
        # Immediate containment actions
        await fraud_handler.freeze_affected_accounts()
        await fraud_handler.notify_risk_management()
        await fraud_handler.notify_compliance()
        
        # Investigation phase
        investigation_result = await fraud_handler.investigate_pattern()
        
        # Decision and action
        if investigation_result.confidence > 0.95:
            await fraud_handler.execute_containment()
            await fraud_handler.file_sar()  # Suspicious Activity Report
        
        # Log results
        logger.info(f"Fraud alert handled in {fraud_handler.elapsed_time}ms")
        
    except Exception as e:
        logger.error(f"Fraud handler failed: {e}")
        await fraud_handler.escalate_to_human()</pre>
          
          <p><strong>Step 5: Resume or Reschedule</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">    finally:
        # Check if we should resume the preempted task
        if self.state_stack:
            suspended_task = self.state_stack.pop()
            
            # Decision logic: resume or reschedule?
            if self.should_resume(suspended_task):
                # Resume immediately if close to completion
                await self.resume_task(suspended_task)
            else:
                # Reschedule for later if it's a long-running task
                await self.reschedule_task(suspended_task)

def should_resume(self, suspended_task):
    """Decide whether to resume immediately or reschedule"""
    progress = suspended_task['checkpoint']['progress']
    elapsed_time = time.time() - suspended_task['timestamp']
    
    # Resume if >80% complete or suspended for <5 minutes
    if progress > 0.8 or elapsed_time < 300:
        return True
    
    # Reschedule if it's a long-running task that just started
    return False</pre>
        </section>

        <section class="blog-section">
          <h2>State Transition Diagram</h2>
          <p>
            The agent moves through five states:
          </p>
          <ul>
            <li><strong>Idle:</strong> No active tasks, waiting for events</li>
            <li><strong>Processing:</strong> Executing a task normally</li>
            <li><strong>Suspended:</strong> Task paused due to higher priority interrupt</li>
            <li><strong>Preempted:</strong> Task interrupted, checkpoint saved, moved to stack</li>
            <li><strong>Recovering:</strong> Restoring from checkpoint and resuming</li>
          </ul>
          
          <p><strong>Key Transitions</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">Idle → Processing: New task arrives
Processing → Preempted: Higher priority event
Preempted → Suspended: Checkpoint saved to stack
Suspended → Recovering: Higher priority task completes
Recovering → Processing: Checkpoint restored, execution resumes
Processing → Idle: Task completes normally</pre>
        </section>

        <section class="blog-section">
          <h2>Real-World Example: Credit Portfolio Management</h2>
          <p>
            Let's see how this works in a realistic scenario:
          </p>
          
          <p><strong>Timeline</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">10:00 AM - Portfolio Rebalancing Starts
          - Analyzing 10,000 positions
          - Optimizing risk-adjusted returns
          - Expected duration: 30 minutes
          
10:15 AM - Fraud Alert! (15 minutes in, 50% complete)
          - Synthetic identity detected
          - $250K exposure
          - PREEMPTION TRIGGERED
          
10:15:05 AM - Checkpoint Saved
            - Progress: 50%
            - 5,000 positions analyzed
            - Partial optimization results stored
            
10:15:06 AM - Fraud Handler Active
            - Freeze accounts: 100ms
            - Notify risk team: 200ms
            - Investigation: 5 seconds
            - Containment executed: 500ms
            - Total time: 6 seconds
            
10:15:12 AM - Fraud Handled, Resume Decision
            - Preempted task was 50% complete
            - Only 15 minutes of work lost if restarted
            - Decision: RESUME from checkpoint
            
10:15:13 AM - Portfolio Rebalancing Resumed
            - Restored from 50% completion
            - Continued with remaining 5,000 positions
            
10:30 AM - Portfolio Rebalancing Complete
          - Total time: 30 minutes (with 6-second interruption)
          - Fraud handled without losing progress</pre>
          
          <p>
            Without preemption, the fraud alert would have waited in queue for 15 minutes, potentially allowing the fraud to spread. With naive interruption (no checkpointing), we'd lose 15 minutes of computation and restart from scratch.
          </p>
        </section>

        <section class="blog-section">
          <h2>Advanced Features: Deadline-Aware Scheduling</h2>
          <p>
            Some tasks have hard deadlines (like margin calls with regulatory time limits). The system includes deadline awareness in its preemption logic:
          </p>
          
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">def enhanced_priority_score(event, current_task):
    """Calculate dynamic priority considering deadlines"""
    base_priority = PRIORITY_LEVELS[event.type]
    
    # Check if current task has an approaching deadline
    if current_task.deadline:
        time_remaining = current_task.deadline - time.time()
        
        # If current task deadline is within 5 minutes, boost its priority
        if time_remaining < 300:
            adjusted_priority = base_priority - 0.5  # Slight priority boost
            logger.warning(f"Current task {current_task.id} has deadline in {time_remaining}s")
            
            # Don't preempt if current task is about to miss deadline
            if time_remaining < 60:
                return False  # Don't preempt
    
    return base_priority</pre>
        </section>

        <section class="blog-section">
          <h2>Failure Recovery and Resilience</h2>
          <p>
            What happens if the system crashes during execution? Checkpoints provide resilience:
          </p>
          
          <p><strong>Automatic Recovery on Restart</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">class ResilientAgent:
    def __init__(self):
        self.checkpoint_dir = "./checkpoints"
        self.recovery_log = "./recovery.log"
        
    async def startup_recovery(self):
        """Recover interrupted tasks on system restart"""
        checkpoint_files = os.listdir(self.checkpoint_dir)
        
        for checkpoint_file in checkpoint_files:
            try:
                # Load checkpoint
                with open(f"{self.checkpoint_dir}/{checkpoint_file}", 'rb') as f:
                    checkpoint = pickle.load(f)
                
                # Check if task is still valid
                if self.is_checkpoint_valid(checkpoint):
                    # Restore task
                    task = self.recreate_task_from_checkpoint(checkpoint)
                    
                    # Add to queue with original priority
                    self.task_queue.add(task, priority=task.priority)
                    
                    logger.info(f"Recovered task {task.id} from checkpoint")
                else:
                    # Checkpoint too old or task no longer relevant
                    os.remove(f"{self.checkpoint_dir}/{checkpoint_file}")
                    
            except Exception as e:
                logger.error(f"Failed to recover checkpoint: {e}")</pre>
        </section>

        <section class="blog-section">
          <h2>Performance Metrics: Measuring Success</h2>
          
          <p><strong>Key Metrics for Priority-Based Systems</strong></p>
          <ul>
            <li><strong>Preemption Overhead:</strong> Time to save checkpoint and context switch (&lt;100ms target)</li>
            <li><strong>Resume Overhead:</strong> Time to restore and continue (&lt;50ms target)</li>
            <li><strong>Priority Inversion Events:</strong> Times when low-priority task blocks high-priority (should be 0)</li>
            <li><strong>Deadline Miss Rate:</strong> Percentage of tasks missing deadlines (target &lt;0.1%)</li>
            <li><strong>Average Response Time by Priority:</strong> How quickly each priority level gets handled</li>
          </ul>
          
          <p><strong>Benchmark Results</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">Priority Level    Avg Response Time    99th Percentile
---------------------------------------------------------
FRAUD_ALERT       150ms               350ms
MARGIN_CALL       2.5s                5.8s
RISK_BREACH       15s                 45s
REBALANCE         5min                15min
REPORTING         30min               2hr

Checkpoint Save:  45ms average
Checkpoint Load:  28ms average
State Transitions: 12ms average</pre>
        </section>

        <section class="blog-section">
          <h2>When Not to Preempt: The Atomic Operation Problem</h2>
          <p>
            Some operations cannot be interrupted safely. Consider a trade execution in progress:
          </p>
          <ul>
            <li>Order sent to exchange</li>
            <li>Waiting for confirmation</li>
            <li>Cannot checkpoint mid-transaction</li>
          </ul>
          
          <p><strong>Atomic Sections</strong></p>
          <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 15px 0; overflow-x: auto;">class AtomicOperation:
    """Operations that cannot be interrupted"""
    
    def __enter__(self):
        self.agent.set_atomic_mode(True)
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.agent.set_atomic_mode(False)

# Usage
async def execute_trade(order):
    with AtomicOperation():
        # This section cannot be preempted
        await exchange.send_order(order)
        confirmation = await exchange.wait_for_confirmation()
        await database.record_trade(confirmation)
    
    # After atomic section, preemption allowed again</pre>
        </section>

        <section class="blog-section">
          <h2>Integration with the Broader Agent System</h2>
          <p>
            Priority-based preemption doesn't exist in isolation. It integrates with:
          </p>
          <ul>
            <li><strong>Continual Learning Module:</strong> Can interrupt model training for urgent events</li>
            <li><strong>RAG System:</strong> Can prioritize retrieval for high-priority queries</li>
            <li><strong>Risk Management:</strong> Real-time risk monitoring triggers preemption</li>
            <li><strong>Compliance:</strong> Regulatory deadlines automatically get high priority</li>
          </ul>
        </section>

        <section class="blog-section">
          <h2>Lessons Learned: Building Production Agent Systems</h2>
          
          <p><strong>1. Checkpointing Is Non-Negotiable</strong></p>
          <p>
            In financial systems, losing computation time is losing money. Checkpoints add complexity but save orders of magnitude more in avoided work.
          </p>
          
          <p><strong>2. Priority Isn't Static</strong></p>
          <p>
            Deadline awareness and dynamic priority adjustment are essential. A low-priority task becomes high-priority when its deadline approaches.
          </p>
          
          <p><strong>3. Atomic Operations Must Be Short</strong></p>
          <p>
            If you can't interrupt an operation, it better complete quickly. Long atomic sections defeat the purpose of preemption.
          </p>
          
          <p><strong>4. Recovery Is Part of the Design</strong></p>
          <p>
            Systems crash. Networks fail. Recovery from checkpoints should be automatic, not an afterthought.
          </p>
          
          <p><strong>5. Metrics Matter</strong></p>
          <p>
            You can't optimize what you don't measure. Response time by priority level, checkpoint overhead, and deadline miss rates guide system tuning.
          </p>
        </section>

        <section class="blog-section">
          <h2>The Future: Multi-Agent Coordination</h2>
          <p>
            The next evolution involves coordinating multiple agents with shared priorities:
          </p>
          <ul>
            <li><strong>Distributed Preemption:</strong> Multiple agents working on different portfolios, coordinating on shared risks</li>
            <li><strong>Resource Arbitration:</strong> When two high-priority tasks need the same API rate limits or compute resources</li>
            <li><strong>Cascading Priorities:</strong> One agent's high-priority event triggering preemption across dependent agents</li>
            <li><strong>Collaborative Checkpointing:</strong> Distributed transactions that checkpoint across multiple agents</li>
          </ul>
        </section>

        <section class="blog-section" style="background: #f5f5f5; padding: 20px; border-left: 4px solid #3b82f6; margin: 30px 0;">
          <p><strong>The Bottom Line:</strong> Priority-based preemption transforms financial agents from rigid task executors into intelligent, responsive systems that handle the constant interruptions of real-world finance. By combining hierarchical priorities, checkpoint-based state management, and deadline awareness, we built agents that respond to fraud in milliseconds while never losing progress on long-running analyses. This isn't just better scheduling; it's the difference between reactive systems and truly intelligent agents.</p>
        </section>

        <div class="back-link">
          <a href="../blogs.html">&larr; Back to Insights</a>
        </div>
      </article>
    </main>
  </div>
</body>
</html>
